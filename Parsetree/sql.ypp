/*
 * Parser for mysql subset, GLR version
 */
%pure-parser
%parse-param { struct ParseResult* result}

%glr-parser
%expect 8
%expect-rr 79
%defines
%{
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <iostream>
#include <stdio.h>
#include <malloc.h>
#include <vector>
using namespace std;
void yyerror(struct ParseResult *pp,const char *s, ...);
%}

%union {
	int intval;		
	double floatval;	// no used ---4-28
	char *strval;
	int subtok;
	struct Node * ast_node;
}
	
	/* names and literal values */
%{
///
#include "sql.lex.h"
#include "sql_node_struct.h"

#define YYLEX_PARAM result->yyscan_info_

/*
should replace YYLEX with the following clause in sql.tab.cpp, why so? I don't know

#ifdef YYLEX_PARAM
# define YYLEX yylex (&yylval, YYLEX_PARAM)
#else
# define YYLEX yylex (&yylval)
#endif
*/

%}
%token <strval> NAME
%token <strval> STRING
%token <strval> INTNUM
%token <strval> BOOL
%token <strval> APPROXNUM

       /* user @abc names */

%token <strval> USERVAR

	/* operators and precedence levels */

%right ASSIGN
%left OR
%left XOR
%left ANDOP
%nonassoc IN IS LIKE REGEXP
%left NOT '!'
%left BETWEEN
%left <subtok> COMPARISON /* = <> < > <= >= <=> */
%left '|'
%left '&'
%left <subtok> SHIFT /* << >> */
%left '+' '-'
%left '*' '/' '%' MOD
%left '^'
%nonassoc UMINUS

%token ADD
%token ALL
%token ALTER
%token ANALYZE
%token AND
%token ANY
%token AS
%token ASC
%token AUTO_INCREMENT
%token BEFORE
%token BETWEEN
%token BIGINT
%token BINARY
%token BIT
%token BLOB
%token BOTH
%token BY
%token CALL
%token CASCADE
%token CASE
%token CHANGE
%token CHAR
%token CHECK
%token COLLATE
%token COLUMN
%token COMMENT
%token CONDITION
%token CONSTRAINT
%token CONTINUE
%token CONVERT
%token CREATE
%token CROSS
%token CURRENT_DATE
%token CURRENT_TIME
%token CURRENT_TIMESTAMP
%token CURRENT_USER
%token CURSOR
%token DATABASE
%token DATABASES
%token DATE
%token DATETIME
%token DAY_HOUR
%token DAY  //---5.26fzh---
%token DAY_MICROSECOND
%token DAY_MINUTE
%token DAY_SECOND
%token DECIMAL
%token DECLARE
%token DEFAULT
%token DELAYED
%token DELETE
%token DESC
%token DESCRIBE
%token DETERMINISTIC
%token DISTINCT
%token DISTINCTROW
%token DIV
%token DOUBLE
%token DROP
%token DUAL
%token EACH
%token ELSE
%token ELSEIF
%token ENCLOSED
%token END
%token ENUM
%token ESCAPED
%token EXISTS
%token EXIT
%token EXPLAIN
%token FETCH
%token FLOAT
%token FOR
%token FORCE
%token FOREIGN
%token FROM
%token FULLTEXT
%token GRANT
%token GROUP
%token HAVING
%token HIGH_PRIORITY
%token HOUR_MICROSECOND
%token HOUR_MINUTE
%token HOUR_SECOND
%token IF
%token IGNORE
%token IN
%token INDEX
%token INFILE
%token INNER
%token INOUT
%token INSENSITIVE
%token INSERT
%token INT
%token INTEGER
%token INTERVAL
%token INTO
%token ITERATE
%token JOIN
%token KEY
%token KEYS
%token KILL
%token LEADING
%token LEAVE
%token LEFT
%token LIKE
%token LIMIT
%token LINES
%token LOAD
%token LOCALTIME
%token LOCALTIMESTAMP
%token LOCK
%token LONG
%token LONGBLOB
%token LONGTEXT
%token LOOP
%token LOW_PRIORITY
%token MATCH
%token MEDIUMBLOB
%token MEDIUMINT
%token MEDIUMTEXT
%token MINUTE_MICROSECOND
%token MINUTE_SECOND
%token MOD
%token MODIFIES
%token NATURAL
%token NOT
%token NO_WRITE_TO_BINLOG
%token NULLX
%token NUMBER
%token ON
%token DUPLICATE
%token OPTIMIZE
%token OPTION
%token OPTIONALLY
%token OR
%token ORDER
%token OUT
%token OUTER
%token OUTFILE
%token PARTITIONED	// 2014-2-24-----by YU
%token PRECISION	
%token PRIMARY
%token PROCEDURE
%token PROJECTION	// 2014-2-24------byYU
%token PURGE
%token QUICK
%token QUARTER //---5.26fzh---
%token READ
%token READS
%token REAL
%token REFERENCES
%token REGEXP
%token RELEASE
%token RENAME
%token REPEAT
%token REPLACE
%token REQUIRE
%token RESTRICT
%token RETURN
%token REVOKE
%token RIGHT
%token ROLLUP
%token SCHEMA
%token SCHEMAS
%token SECOND_MICROSECOND
%token SELECT
%token SENSITIVE
%token SEPARATOR
%token SET
%token SHOW
%token SMALLINT
%token SOME
%token SONAME
%token SPATIAL
%token SPECIFIC
%token SQL
%token SQLEXCEPTION
%token SQLSTATE
%token SQLWARNING
%token SQL_BIG_RESULT
%token SQL_CALC_FOUND_ROWS
%token SQL_SMALL_RESULT
%token SSL
%token STARTING
%token STRAIGHT_JOIN
%token TABLE
%token TEMPORARY
%token TEXT
%token TERMINATED
%token THEN
%token TIME
%token TIMESTAMP
%token TINYBLOB
%token TINYINT
%token TINYTEXT
%token TO
%token TRAILING
%token TRIGGER
%token UNDO
%token UNION
%token UNIQUE
%token UNLOCK
%token UNSIGNED
%token UPDATE
%token USAGE
%token USE
%token USING
%token UTC_DATE
%token UTC_TIME
%token UTC_TIMESTAMP
%token VALUES
%token VARBINARY
%token VARCHAR
%token VARYING
%token WHEN
%token WHERE
%token WHILE
%token WITH
%token WRITE
%token XOR
%token YEAR
%token YEAR_MONTH
%token ZEROFILL

%token WEEK //---5.26fzh---

/** added by yukai **/
%token DO
%token MAX_QUERIES_PER_HOUR
%token MAX_UPDATES_PER_HOUR
%token MAX_CONNECTIONS_PER_HOUR
%token MAX_USER_CONNECTIONS
%token USER
%token TRUNCATE
%token FAST
%token MEDIUM
%token EXTENDED
%token CHANGED
%token LEAVES
%token MASTER
%token QUERY CACHE
%token SLAVE
%token BEGINT
%token COMMIT
%token START
%token TRANSACTION
%token NO
%token CHAIN
%token AUTOCOMMIT
%token SAVEPOINT
%token ROLLBACK
%token LOCAL
%token TABLES
%token ISOLATION
%token LEVEL
%token GLOBAL
%token SESSION
%token UNCOMMITTED
%token COMMITTED
%token REPEATABLE
%token SERIALIZABLE
%token IDENTIFIED
%token PASSWORD
%token PRIVILEGES
%token BACKUP
%token CHECKSUM
%token REPAIR
%token USE_FRM
%token RESTORE
%token CHARACTER
%token COLLATION
%token COLUMNS
%token ENGINE
%token LOGS
%token STATUS
%token STORAGE 
%token ENGINES
%token ERRORS
%token GRANTS
%token INNODB
%token PROCESSLIST
%token TRIGGERS
%token VARIABLES
%token WARNINGS
%token FLUSH
%token HOSTS
%token DES_KEY_FILE
%token USER_RESOURCES
%token CONNECTION
%token RESET
%token PREPARE
%token DEALLOCATE
%token EXECUTE
%token WORK
%token BTREE
%token HASH
%token BDB
%token OPEN
%token FULL
 /* functions with special syntax */
%token FSUBSTRING
%token FTRIM
%token FDATE_ADD FDATE_SUB
%token FCOUNT
//---3.25fzh----
%token FUPPER
%token FCAST
%token FCOALESCE
%token FCONVERT

//---2.18 add aggrection function
%token FSUM
%token FAVG
%token FMIN
%token FMAX
  
/**********/


%type <intval> select_opts opt_with_rollup opt_asc_desc opt_inner_cross left_or_right 
%type <intval> opt_left_or_right_outer opt_outer  insert_opts
%type <strval>  opt_as_alias  trim_ltb //---3.25fzh---
%type <ast_node> stmt_list date_type //---3.25fzh---
%type <ast_node> select_expr_list opt_where select_stmt stmt opt_groupby select_expr
%type <ast_node> expr_list opt_expr_list  case_list  opt_having opt_orderby expr
%type <ast_node> groupby_list opt_limit table_reference table_factor
%type <ast_node> table_references opt_into_list opt_join_condition join_condition
%type <ast_node> column_list  table_subquery  join_table
%type <ast_node> index_list opt_for_join opt_col_names
%type <ast_node> delete_opts delete_list 
%type <ast_node> insert_vals insert_vals_list
%type <ast_node> insert_asgn_list update_asgn_list
%type <ast_node> opt_length  enum_list
%type <ast_node> column_atts create_col_list

%type <intval> update_opts	// 2014-3-24---change position at here---by Yu

%type <ast_node> opt_ondupupdate insert_stmt	

%type <ast_node>interval_exp //---5.26fzh----

/** add by yukai **/

%type <strval> opt_from opt_like_string	// 2014-5-4---add---by Yu
%type <ast_node> create_database_stmt create_table_stmt  create_select_statement
%type <ast_node> create_definition alter_database_stmt alter_table_stmt opt_csc	
%type <ast_node> alter_list alter_def data_type create_projection_stmt
%type <ast_node> truncate_stmt
%type <ast_node> create_index_stmt index_col_list drop_index_stmt	
%type <ast_node> drop_database_stmt drop_table_stmt table_list	
%type <ast_node> load_table_stmt	
%type <ast_node> show_stmt	// 2014-5-4---add---by Yu
%type <intval> opt_rc  opt_ignore opt_if_exists	opt_using_type		
%type <intval> opt_col index_att index_type rename_list
%type <intval> opt_chain opt_release opt_read_write
%type <intval> opt_trans_level trans_att priv_database_type priv_table_type
%type <intval> analyze_opt check_opts checksum_opt repair_opts opt_full
%type <intval> opt_index_key flush_opt flush_opt_list opt_connection_query
%type <intval> reset_opt reset_opt_list opt_ignore_replace opt_if_not_exists
%type <intval> opt_temporary  opt_binary opt_uz

/*		// 2014-3-7---don't use this way to recovery from error---byYU
%destructor	{ if(result->error_number ) { puts("All node freed successfully!!"); FreeAllNode(result->node_pointerresult->node_pointer); } }<ast_node>
*/

%start stmt_list

%%

stmt_list: stmt ';'		{ 	
  						printf("> \n"); 
  						$$ = newStmt(t_stmt, NULL, $1,result->node_pointer); 
  						if (result->error_number == 0) 
  						{
  							result->ast  = $$;
  						}
  						else
  						{
  							result->ast  = NULL;
  						} 
  						/* output($$, 1);*/ 
  					}	
	| stmt_list stmt ';'	{ 	
	  					printf(">> \n"); 
	  					$$ = newStmt(t_stmt, $1, $2,result->node_pointer); 
	  					if (result->error_number == 0)
	  					{
	  						result->ast  = $$;
	  					}
	  					else
	  					{
	  						result->ast  = NULL;
	  					}
	  					/*output($$, 1);*/ 
	  				}		
  	| error ';'			{ 
  						printf("> \n");
  						result->ast  = NULL;	
  						result->error_number++;	
  						//yyerror(result,"First statement discarded, input new statement"); 
  						yyclearin;
  						yyerrok; 				
  					}	// 2014-3-4---support error---byYU
  	| stmt_list error ';'	{ 
  						printf(">> \n"); 
  						result->ast  = NULL;	// 2014-3-6---if error, the last root is set be null---byYU
  						result->error_number++;		// 2014-3-6---error number add by 1---byYU
  						//yyerror(result,"Current statement discarded, input new statement"); 
  						yyclearin;
  						yyerrok; 
  					}	// 2014-3-4---add support error---byYU
  	;

   /* statements: select statement */

stmt: select_stmt { $$=$1; /*output($$, 1);puts("SQL parser： This is a select statement"); */ }		
	;

select_stmt: 
	SELECT select_opts select_expr_list
	{
		$$ = newQueryStmt(t_query_stmt, NULL, $2, $3, NULL, NULL, NULL, NULL, NULL, NULL, NULL,result->node_pointer);
		/*puts("SQL parser： select_stmt1");	*/ 
	}
	| SELECT select_opts select_expr_list FROM table_references opt_where 
    			opt_groupby opt_having opt_orderby opt_limit opt_into_list 
		{
			$$ = newQueryStmt(t_query_stmt, NULL, $2, $3, $5, $6, $7, $8, $9, $10, $11,result->node_pointer);
			/*puts("SQL parser： select_stmt2");	*/ 
		}

	;

opt_where: /* nil */	{ $$= NULL; /*puts("opt_where is null")*/; }
	| WHERE expr 		{ $$ = newWhereList(t_where_list, NULL, $2,result->node_pointer); /*puts("opt_where");*/};

opt_groupby: /* nil */ { $$=NULL; /*puts("opt_groupby is null");*/ }
	| GROUP BY groupby_list opt_with_rollup { $$ = newGroupbyList(t_groupby_list, NULL, $3, $4,result->node_pointer); /*puts("opt_groupby");*/}
	;

groupby_list: expr opt_asc_desc
	{ 
		$$=newGroupbyExpr(t_groupby_expr, $1, $2, NULL,result->node_pointer);
		/*puts("groupby_list1");*/
	}
	| expr opt_asc_desc ',' groupby_list
	{
		$$=newGroupbyExpr(t_groupby_expr, $1, $2, $4,result->node_pointer);
		/*puts("groupby_list2");*/
	}
	;

opt_asc_desc: /* nil */ { $$ = 0; }
   | ASC                { $$ = 0; }
   | DESC               { $$ = 1; }
    ;

opt_with_rollup: /* nil */  { $$ = 0; }
   | WITH ROLLUP  { $$ = 1; }
   ;

opt_having: /* nil */ { $$=NULL; /*puts("opt_having is null");*/ }
	| HAVING expr 
	{
		$$=newHavingList(t_having_list, NULL, $2,result->node_pointer);
		/*puts("opt_having2");*/
	}
	;

opt_orderby: /* nil */ { $$=NULL; /*puts("opt_orederby is null");*/ }//this is why the orderby 's next connected with groupexpr
	| ORDER BY groupby_list 
	{
		$$=newOrderbyList(t_orderby_list, NULL, $3,result->node_pointer);
		/*puts("opt_orederby2");*/
	}
	;

opt_limit: /* nil */ {$$ = NULL; /*puts("opt_limit is null");*/ }
	| LIMIT expr { $$=newLimitExpr(t_limit_expr, NULL, $2,result->node_pointer); /*puts("opt_limit2");*/ }
  	| LIMIT expr ',' expr { $$=newLimitExpr(t_limit_expr, $2, $4,result->node_pointer); }
	; 

opt_into_list: /* nil */ { $$=NULL; /*puts("opt_into_list is null");*/ }//no
   | INTO column_list {  }							//-----------------------
   ;

column_list: NAME { $$ = newColumn(t_column, $1, NULL, NULL,result->node_pointer); }
  | NAME ',' column_list { $$ = newColumn(t_column, $1, NULL, $3,result->node_pointer); }
  ;

select_opts:                      { $$ = 0; }
| select_opts ALL                 { if($$ & 1) yyerror(result,"duplicate ALL option"); $$ = $1 | 1; }
| select_opts DISTINCT            { if($$ & 2) yyerror(result,"duplicate DISTINCT option"); $$ = $1 | 2; }
| select_opts DISTINCTROW         { if($$ & 4) yyerror(result,"duplicate DISTINCTROW option"); $$ = $1 | 4; }
| select_opts HIGH_PRIORITY       { if($$ & 8) yyerror(result,"duplicate HIGH_PRIORITY option"); $$ = $1 | 8; }
| select_opts STRAIGHT_JOIN       { if($$ & 16) yyerror(result,"duplicate STRAIGHT_JOIN option"); $$ = $1 | 16; }
| select_opts SQL_SMALL_RESULT    { if($$ & 32) yyerror(result,"duplicate SQL_SMALL_RESULT option"); $$ = $1 | 32; }
| select_opts SQL_BIG_RESULT      { if($$ & 64) yyerror(result,"duplicate SQL_BIG_RESULT option"); $$ = $1 | 64; }
| select_opts SQL_CALC_FOUND_ROWS { if($$ & 128) yyerror(result,"duplicate SQL_CALC_FOUND_ROWS option"); $$ = $1 | 128; }
    ;

select_expr_list: select_expr			{ $$ = newSelectList(t_select_list, 0, $1, NULL,result->node_pointer); /*puts("select_expr_list1");*/ }
    | select_expr ',' select_expr_list	{ $$ = newSelectList(t_select_list, 0, $1, $3,result->node_pointer); /*puts("select_expr_list2");*/ }
    | '*'						{ $$ = newSelectList(t_select_list, 1, NULL, NULL,result->node_pointer); /*puts("select_expr_list3");*/ }
    | '*' ',' select_expr_list		{ $$ = newSelectList(t_select_list, 1, NULL, $3,result->node_pointer); /*puts("select_expr_list4");*/ }	//---3.6fzh---
    ;

select_expr: expr opt_as_alias	{ $$ = newSelectExpr(t_select_expr, $2, $1,result->node_pointer); /*puts("select_expr");*/ }
	;

table_references: table_reference			{ $$=newFromList(t_from_list, $1, NULL,result->node_pointer); /*puts("table_references1");*/ }
    | table_reference ',' table_references	{ $$=newFromList(t_from_list, $1, $3,result->node_pointer); /*puts("table_references2");*/ }
    ;

table_reference:  table_factor { $$=$1; /*puts("table_referen1");*/ }
  	| join_table { $$=$1; /*puts("table_referen2");*/ }
	;

table_factor:
	NAME opt_as_alias/* index_hint */
	{
		$$=newTable(t_table, NULL,$1, $2, 0, NULL,result->node_pointer);
		/*puts("table_factor1");*/
	}
  	| NAME '.' NAME opt_as_alias /*index_hint*/ 
  	{
		$$=newTable(t_table, $1, $3, $4, 0, NULL,result->node_pointer);
   		/*puts("table_factor2");*/ 
   	}
  	| table_subquery opt_as NAME 
  	{
		$$=newTable(t_table, NULL, NULL, $3, 1, $1,result->node_pointer);
	}
	| '(' table_references ')' { $$=$2; }
  	;

opt_as: /* nil */
  | AS 
  ;

opt_as_alias: AS NAME { $$=$2; /*puts("opt_as_alias1");*/ }
  | NAME              { $$=$1; /*puts("opt_as_alias2");*/ }
  | /* nil */         { $$=NULL; /*puts("opt_as_alias3");*/ }
  ;

/*
inner 1
cross 2
outer 4
left 8
right 16
nature 32
straight_join -1
*/


join_table:// enumerate every different paramters
	table_reference opt_inner_cross JOIN table_factor opt_join_condition
	{
		$$=newJoin(t_join, $2, $1, $4, $5,result->node_pointer);
	}              
	| table_reference STRAIGHT_JOIN table_factor 
	{
		$$=newJoin(t_join, -1, $1, $3, NULL,result->node_pointer);
	}
	| table_reference STRAIGHT_JOIN table_factor ON expr  
	{
		Node *m=newCondition(t_condition, 1, $5,result->node_pointer);
		$$=newJoin(t_join, -1, $1, $3, m,result->node_pointer);
	}
  	| table_reference left_or_right opt_outer JOIN table_factor join_condition
    	{
		$$=newJoin(t_join, $2+$3, $1, $5, $6,result->node_pointer);
    	}
  	| table_reference NATURAL opt_left_or_right_outer JOIN table_factor
	{
		$$=newJoin(t_join, 32 + $3, $1, $5, NULL,result->node_pointer);
	}
  	;

opt_inner_cross: /* nil */ { $$ = 0; }
   	| INNER	{ $$ = 1; }
   	| CROSS	{ $$ = 2; }
	;

opt_outer: /* nil */{ $$ = 0; }
	| OUTER	{$$ = 4; }
   	;

left_or_right: LEFT	{ $$ = 8; }
    | RIGHT { $$ = 16; }
    ;

opt_left_or_right_outer: LEFT opt_outer	{ $$ = 8 + $2; }
	| RIGHT opt_outer  { $$ = 16 + $2; }
	| /* nil */ { $$ = 0; }
	;

opt_join_condition: /* nil */	{}
	| join_condition	{$$=$1;}
	;
/*
on 1
using 2
*/

join_condition: ON expr 
    {
    	$$=newCondition(t_condition, 1, $2,result->node_pointer);
    }
    | USING '(' column_list ')' 
    {
    	$$=newCondition(t_condition, 2, $3,result->node_pointer);
    }
    ;

index_hint://暂时没有考虑
     USE KEY opt_for_join '(' index_list ')'
                  {  }
   | IGNORE KEY opt_for_join '(' index_list ')'
                  { }
   | FORCE KEY opt_for_join '(' index_list ')'
                  {  }
   | /* nil */
   ;

opt_for_join: FOR JOIN { $$ = 1; }//no
   | /* nil */ { $$ = 0; }//no
   ;

index_list: NAME  { emit("INDEX %s", $1);  }////////////////////////////////////////////////////////////////////////////////
   | index_list ',' NAME { emit("INDEX %s", $3); }//////////////////////////////////////////////////////////////////////////
   ;

table_subquery: '(' select_stmt ')' { $$=$2; }//---3.14fzh---
   ;

   /* statements: delete statement */

stmt: delete_stmt { emit("STMT"); }
   ;

delete_stmt: DELETE delete_opts FROM NAME
    opt_where opt_orderby opt_limit
                  { emit("DELETEONE %d %s", $2, $4); free($4); }
;

delete_opts: delete_opts LOW_PRIORITY { $$ = $1 + 01; }
   | delete_opts QUICK { $$ = $1 + 02; }
   | delete_opts IGNORE { $$ = $1 + 04; }
   | /* nil */ { $$ = 0; }
   ;

delete_stmt: DELETE delete_opts
    delete_list
    FROM table_references opt_where
            {  }
;
delete_list: NAME opt_dot_star {  }
   | delete_list ',' NAME opt_dot_star {  }
   ;

opt_dot_star: /* nil */ 
   | '.' '*' 
   ;

delete_stmt: DELETE delete_opts FROM delete_list USING table_references opt_where
   { emit("DELETEMULTI %d %d %d", $2, $4, $6); }
   ;

   /* statements: insert statement */	//2014-4-17---add---by Yu

stmt: insert_stmt { $$=$1; /*output($$, 1); puts("SQL parser： This is a insert statement");*/ }	//2014-4-16---add---by Yu
   ;

insert_stmt: INSERT insert_opts opt_into NAME
     opt_col_names
     VALUES insert_vals_list
     opt_ondupupdate { $$ = newInsertStmt($2, $4, $5, $7, $8, NULL, NULL,result->node_pointer); }
   ;

opt_ondupupdate: /* nil */				{ $$ = NULL; }
   | ON DUPLICATE KEY UPDATE insert_asgn_list	{ $$ = $5; }
   ;

insert_opts: /* nil */			{ $$ = 0; }
   | insert_opts LOW_PRIORITY		{ $$ = $1 | 01 ; }
   | insert_opts DELAYED 		{ $$ = $1 | 02 ; }
   | insert_opts HIGH_PRIORITY 	{ $$ = $1 | 04 ; }
   | insert_opts IGNORE			{ $$ = $1 | 010 ; }
   ;

opt_into: INTO | /* nil */
	;

opt_col_names: /* nil */	{ $$ = NULL; }
   | '(' column_list ')'	{ $$ = $2; }
   ;

insert_vals_list: '(' insert_vals ')'		{ $$ = newInsertValueList($2, NULL,result->node_pointer); }
   | insert_vals_list ',' '(' insert_vals ')'	{ $$ = newInsertValueList($4, $1,result->node_pointer); }	//2014-4-17---Attention: the order can be reversed---by Yu
   ;
   
insert_vals:
     expr		{ $$ = newInsertVals(0, $1, NULL,result->node_pointer); }
   | DEFAULT	{ $$ = newInsertVals(1, NULL, NULL,result->node_pointer); }
   | expr ',' insert_vals	{ $$ = newInsertVals(0, $1, $3,result->node_pointer); }
   | DEFAULT ',' insert_vals	{ $$ = newInsertVals(1, NULL, $3,result->node_pointer); }
   ;

insert_stmt: INSERT insert_opts opt_into NAME 
	SET insert_asgn_list opt_ondupupdate	{ $$ = newInsertStmt($2, $4, NULL, NULL, $7, $6, NULL,result->node_pointer); }
   ;

insert_stmt: INSERT insert_opts opt_into NAME opt_col_names
    select_stmt opt_ondupupdate { $$ = newInsertStmt($2, $4, $5, NULL, $7, NULL, $6,result->node_pointer); }
  ;

insert_asgn_list:
	NAME COMPARISON expr { 
		if($2 != 4) yyerror(result,"bad insert assignment to %s", $1); 
		else $$ = newInsertAssignList($1, 0, $3, NULL,result->node_pointer); }
	| NAME COMPARISON DEFAULT { 
		if ($2 != 4) yyerror(result,"bad insert assignment to %s", $1);
 		else $$ = newInsertAssignList($1, 1, NULL, NULL,result->node_pointer); }
	| insert_asgn_list ',' NAME COMPARISON expr { 
		if ($4 != 4) yyerror(result,"bad insert assignment to %s", $1);		 
		else $$ = newInsertAssignList($3, 0, $5, $1,result->node_pointer); }
	| insert_asgn_list ',' NAME COMPARISON DEFAULT { 
		if ($4 != 4) yyerror(result,"bad insert assignment to %s", $1);
		else $$ = newInsertAssignList($3, 1, NULL, $1,result->node_pointer); }
   ;

   /** replace just like insert **/
stmt: replace_stmt { emit("STMT"); }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME
     opt_col_names
     VALUES insert_vals_list
     opt_ondupupdate { emit("REPLACEVALS %d %d %s", $2, $7, $4); free($4) }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME
    SET insert_asgn_list
    opt_ondupupdate
     { emit("REPLACEASGN %d %d %s", $2, $6, $4); free($4) }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME opt_col_names
    select_stmt
    opt_ondupupdate { emit("REPLACESELECT %d %s", $2, $4); free($4); }
  ;

/** update **/
stmt: update_stmt { emit("STMT"); }
   ;

update_stmt: UPDATE update_opts table_references
    SET update_asgn_list
    opt_where
    opt_orderby
opt_limit { emit("UPDATE %d %d %d", $2, $3, $5); }
;

// 2014-3-24---修改---by Yu
update_opts: /* nil */		{ $$ = 0; }
   | insert_opts LOW_PRIORITY	{ $$ = $1 | 01; }
   | insert_opts IGNORE		{ $$ = $1 | 02; }
   ;

update_asgn_list:
	NAME COMPARISON expr 
	{
		/*
		if ($2 != 4 || $3->data.string_val == NULL) 
			yyerror(result,"bad insert assignment to %s", $1);
	 	emit("ASSIGN %s", $1); 
	 	free($3); 
	 	$$ = $3->data.string_val;
	 	*/ 
	}
	| NAME '.' NAME COMPARISON expr 
	{ 
	/*
		if ($4 != 4) 
			yyerror(result,"bad insert assignment to %s", $1); 
		emit("ASSIGN %s.%s", $1, $3);
		free($1); 
		free($3); 
		$$ = 1;
	*/
	}
	| update_asgn_list ',' NAME COMPARISON expr
	//     { if ($4 != 4) yyerror(result,"bad insert assignment to %s", $3); emit("ASSIGN %s.%s", $3); free($3); $$ = $1 + 1; }
	| update_asgn_list ',' NAME '.' NAME COMPARISON expr
	//     { if ($6 != 4) yyerror(result,"bad insert assignment to %s.$s", $3, $5); 
	//		emit("ASSIGN %s.%s", $3, $5); free($3); free($5); $$ = 1;
	//		}
	;


   /** create database **/

stmt: create_database_stmt { $$=$1;/* output($$, 1); puts("SQL parser： This is a create_database statement");*/ }	
   ;

create_database_stmt: 
	CREATE DATABASE opt_if_not_exists NAME 
		{ $$ =  newCreateDatabaseStmt(t_create_database_stmt, 1, $3, $4,result->node_pointer); }
	| CREATE SCHEMA opt_if_not_exists NAME 
		{ $$ =  newCreateDatabaseStmt(t_create_database_stmt, 2, $3, $4,result->node_pointer); }
	;

opt_if_not_exists:  /* nil */ { $$ = 0; } 
   | IF NOT EXISTS            { $$ = 1; } 
   ;

   /** create table **/
   
stmt: create_table_stmt { $$=$1;/* output($$, 1); puts("SQL parser： This is a create_table statement"); */}	
   ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
	'(' create_col_list ')'  { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, NULL, $7, NULL,result->node_pointer); }
	;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
   '(' create_col_list ')' { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, $7, $9, NULL,result->node_pointer); }
   ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
   '(' create_col_list ')' create_select_statement 
   { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, NULL, $7, $9,result->node_pointer); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
   create_select_statement { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, NULL, NULL, $6,result->node_pointer); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
   '(' create_col_list ')' create_select_statement  
   { $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, $7, $9, $11,result->node_pointer); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
	create_select_statement 
	{ $$ = newCreateTableStmt(t_create_table_stmt, $2, $4, $5, $7, NULL, $8,result->node_pointer); }
	;

	
create_select_statement: opt_ignore_replace opt_as select_stmt 
	{ $$ = newCreateSelectStmt(t_create_select_stmt, $1, 0, $3,result->node_pointer); }
	;

opt_ignore_replace: /* nil */	{ $$ = 0; }
	| IGNORE		{ $$ = 1; }
	| REPLACE 		{ $$ = 2; }
	;

opt_temporary: /* nil */{ $$ = 0; }
	| TEMPORARY 		{ $$ = 1; }
	;

create_col_list: create_definition { $$ = newCreateColList(t_create_col_list, $1, NULL,result->node_pointer); }
	| create_definition ',' create_col_list { $$ = newCreateColList(t_create_col_list, $1, $3,result->node_pointer); }
	;

create_definition: 	/* 2-18---add name attribute---byYU */
    NAME data_type column_atts		{ $$ = newCreateDef( t_create_def, 1, $1, $2, $3, NULL,result->node_pointer); }
    | PRIMARY KEY '(' column_list ')'	{ $$ = newCreateDef( t_create_def, 2, NULL, NULL, NULL, $4,result->node_pointer); /*puts("primary key ok!");*/ }
    | KEY '(' column_list ')'			{ $$ = newCreateDef( t_create_def, 3, NULL, NULL, NULL, $3,result->node_pointer); }
    | INDEX '(' column_list ')'		{ $$ = newCreateDef( t_create_def, 4, NULL, NULL, NULL, $3,result->node_pointer); }
    | FULLTEXT INDEX '(' column_list ')'	{ $$ = newCreateDef( t_create_def, 5, NULL, NULL, NULL, $4,result->node_pointer); }
    | FULLTEXT KEY '(' column_list ')'	{ $$ = newCreateDef( t_create_def, 6, NULL, NULL, NULL, $4,result->node_pointer); }
     ;

// 2014-4-14---change '+=' to '|=', save data in t->data ---Yu
column_atts: /* nil */				{ $$ = newColumnAtts(t_column_atts, 0, 0, 0, NULL, NULL,result->node_pointer); }
    | column_atts NOT NULLX			{ Column_atts *t = (Column_atts *)$1; t->datatype |= 01; $$ = (Node *)t; }
    | column_atts NULLX				{ Column_atts *t = (Column_atts *)$1; t->datatype |= 02; $$ = (Node *)t; }
    | column_atts DEFAULT STRING        	{ Column_atts *t = (Column_atts *)$1; t->datatype |= 04; t->s = $3; $$ = (Node *)t; }
    | column_atts DEFAULT INTNUM		{ Column_atts *t = (Column_atts *)$1; t->datatype |= 010; t->num1 = atoi($3); $$ = (Node *)t; }
    | column_atts DEFAULT APPROXNUM 	{ Column_atts *t = (Column_atts *)$1; t->datatype |= 020; t->num2 = atof($3); $$ = (Node *)t; }
    | column_atts DEFAULT BOOL          	{ Column_atts *t = (Column_atts *)$1; t->datatype |= 040; t->num1 = atoi($3); $$ = (Node *)t; }
    | column_atts AUTO_INCREMENT        	{ Column_atts *t = (Column_atts *)$1; t->datatype |= 0100; $$ = (Node *)t; }
    | column_atts UNIQUE KEY 			{ Column_atts *t = (Column_atts *)$1; t->datatype |= 0200; $$ = (Node *)t; }
    | column_atts PRIMARY KEY			{ Column_atts *t = (Column_atts *)$1; t->datatype |= 0400; $$ = (Node *)t; }
    | column_atts KEY 				{ Column_atts *t = (Column_atts *)$1; t->datatype |= 01000; $$ = (Node *)t; }
    | column_atts COMMENT STRING 		{ Column_atts *t = (Column_atts *)$1; t->datatype |= 02000; $$ = (Node *)t; }
    | column_atts UNIQUE '(' column_list ')'	{ Column_atts *t = (Column_atts *)$1; t->datatype |= 04000; t->col_list = $4; $$ = (Node *)t; }	
    ;
    
	/** create projection **/	
stmt: create_projection_stmt	{ $$ = $1;/* puts("SQL parser： This is a create_projection statement");*/ }
	;
	
	
create_projection_stmt: CREATE PROJECTION ON NAME '(' column_list ')' PARTITIONED ON NAME	
		{ $$ = newCreateProjectionStmt(t_create_projection_stmt, $4, $6, 1, $10,result->node_pointer); }
	| CREATE PROJECTION ON NAME '(' column_list ')' NUMBER COMPARISON INTNUM PARTITIONED ON NAME
	{ 
		if ($9 != 4) { yyerror(result,"please give a specific number"); } 
		else { $$ = newCreateProjectionStmt(t_create_projection_stmt, $4, $6, atoi($10), $13,result->node_pointer); }
	}
	;
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/** do expr **/
stmt: DO expr_list { $$ = newDoStmt(t_do_stmt,$2,result->node_pointer);/* puts("SQL parser： This is a do expr statement");*/ }	
    ;
    
	/** truncate stmt **/
stmt: truncate_stmt { $$ = $1; /*puts("SQL parser： This is a truncate_stmt statement");*/ }
    ;
	
truncate_stmt: TRUNCATE NAME	{ $$ = newTruncateStmt(t_truncate_stmt, $2,result->node_pointer); }
    | TRUNCATE TABLE NAME	{ $$ = newTruncateStmt(t_truncate_stmt, $3,result->node_pointer); }
    ;

   /** alter database **/
stmt: alter_database_stmt { $$=$1;/* output($$, 1); puts("SQL parser： This is a alter_database statement");*/ }
	;

alter_database_stmt:	// 2-19--- change function name---byYU
	ALTER DATABASE NAME opt_csc 	{ $$ = newAlterDatabaseStmt(t_alter_database_stmt, 1, $3, $4,result->node_pointer); }	
   | ALTER SCHEMA NAME opt_csc	{ $$ = newAlterDatabaseStmt(t_alter_database_stmt, 2, $3, $4,result->node_pointer); }
	;
   
   /** alter table **/	// 2-19---change alter table ---byYU
stmt: alter_table_stmt	{ $$=$1; /*output($$, 1); puts("SQL parser： This is a alter_table statement"); */}	// 2014-3-5---优化输出信息，指明来自SQL parser---byYU
	;
	
/*MySQL,ALTER TABLE statement can contain  ADD, ALTER, DROP and CHANGE，divied by ,*/   
alter_table_stmt:
	ALTER opt_ignore TABLE NAME alter_list { $$ = newAlterTableStmt(t_alter_table_stmt, $2, $4, $5,result->node_pointer); }
   ;

alter_list:
	alter_def
   | alter_list ',' alter_def
   ;
   
alter_def: 
	ADD opt_col create_col_list {}
   | CHANGE opt_col NAME NAME data_type column_atts {}
   | DROP opt_col NAME 
   | DROP PRIMARY KEY
   | DROP INDEX column_list
   | DROP FOREIGN KEY column_list
   | RENAME NAME {}
   | RENAME TO NAME {}
   | ORDER BY NAME
   ;
   
opt_col: /* nil */ { $$ = 0; }
   | COLUMN { $$ = 1; }
   ;
   
   
opt_ignore: /* nil */ { $$ = 0; }
   | IGNORE { $$ = 1; }
   ;
	
    /** create index **/	
stmt: create_index_stmt { $$=$1;/* output($$, 1); puts("SQL parser： This is a create_index statement");*/ }
	;
	
create_index_stmt:
	CREATE index_att INDEX NAME opt_using_type ON NAME '(' index_col_list ')'	
	{ $$ = newCreateIndex(t_create_index_stmt, $2, $4, $5, $7, $9,result->node_pointer); }
	;
	
index_att: /* nil */ { $$ = 0;} 
   | UNIQUE 	{ $$ = 1; }
   | FULLTEXT	{ $$ = 2; }
   | SPATIAL	{ $$ = 3; }
   ;
   
opt_using_type: 		{ $$ = 0; }
    | USING index_type	{ $$ = $2; }
    ;
	
index_type: BTREE	{ $$ = 1; }
	| HASH	{ $$ = 2; }
	;
	
index_col_list: NAME opt_length opt_asc_desc			{ $$ = newIndexColList(t_index_col_list, $1, $2, $3, NULL,result->node_pointer); }
	| NAME opt_length opt_asc_desc ',' index_col_list	{ $$ = newIndexColList(t_index_col_list, $1, $2, $3, $5,result->node_pointer); }
	;
	
	/** drop index **/	
stmt: drop_index_stmt { $$=$1; /*output($$, 1); puts("SQL parser： This is a drop_index statement");*/ }
    ;
	
drop_index_stmt: DROP INDEX NAME ON NAME	{ $$ = newDropIndex(t_drop_index, $3, $5,result->node_pointer); }
    ;
	
	/**	drop database **/		
stmt: drop_database_stmt { $$=$1;/* output($$, 1); puts("SQL parser： This is a drop_database statement");*/ }
	;
	
drop_database_stmt: 
	DROP DATABASE opt_if_exists NAME	{ $$ = newDropDatabase(t_drop_database_stmt, 1, $3, $4,result->node_pointer); }
   | DROP SCHEMA opt_if_exists NAME 	{ $$ = newDropDatabase(t_drop_database_stmt, 2, $3, $4,result->node_pointer); }
   ;
   
opt_if_exists: /* nil */	{ $$ = 0; }
   | IF EXISTS			{ $$ = 1; }
   ;
   
   /** drop table **/	
stmt: drop_table_stmt { $$=$1; /*output($$, 1); puts("SQL parser： This is a drop_table statement"); */}

drop_table_stmt:
	DROP opt_temporary TABLE opt_if_exists table_list opt_rc	{ $$ = newDropTable(t_drop_table_stmt, $2, $4, $6, $5,result->node_pointer); }
	;
	
table_list: NAME 					{ $$ = newTableList(t_table_list, NULL, $1, NULL,result->node_pointer); }
	| NAME '.' NAME				{ $$ = newTableList(t_table_list, $1, $3, NULL,result->node_pointer); }
	| table_list ',' NAME			{ $$ = newTableList(t_table_list, NULL, $3, $1,result->node_pointer); }
	| table_list ',' NAME '.' NAME	{ $$ = newTableList(t_table_list, $3, $5, $1,result->node_pointer); }
	;

opt_rc: /* nil */ 	{ $$ = 0; }
   | RESTRICT	 	{ $$ = 1; }
   | CASCADE 		{ $$ = 2; }
   ;
   
   /** load table **/	
stmt: load_table_stmt	{ $$=$1;/* output($$, 1); puts("SQL parser： This is a load_table statement");*/ }
	;
	
load_table_stmt: LOAD TABLE NAME FROM expr_list WITH STRING ',' STRING	{ $$ = newLoadTable(t_load_table_stmt, $3, $5, $7, $9,result->node_pointer);}
	;
   
   /** rename table **/
stmt: rename_table_stmt { emit("STMT"); }
   ;
   
rename_table_stmt: RENAME TABLE rename_list {}
   ;
   
rename_list: /* nil */	{}
   | NAME TO NAME	{}
   | NAME '.' NAME TO NAME '.' NAME {}
   | rename_list ',' NAME TO NAME {}
   | rename_list ',' NAME '.' NAME TO NAME '.' NAME {}
   ;

     /** describe name **/
stmt: describe_stmt { emit("STMT"); }
   ;
   
describe_stmt: DESCRIBE NAME {}
   | DESC NAME {}
   ;
   
   /** use database **/
stmt: use_stmt { emit("STMT"); }
   ;
   
use_stmt: USE NAME {}
   ;
   
   /** start transaction, commit, rollback **/
stmt: start_transaction_stmt { emit("STMT"); }
   | commit_stmt { emit("STMT"); }
   | rollback_stmt { emit("STMT"); }
   ;
   
start_transaction_stmt: START TRANSACTION 
   | BEGINT opt_work
   ;
   
opt_work: /* nil */
   | WORK
   ;
   
commit_stmt: COMMIT opt_work opt_chain opt_release { emit("STMT"); }
   ;
   
 opt_chain: /* nil */	{ $$ = 0; }
   | AND NO CHAIN	{ $$ = 1; }
   | AND CHAIN	{ $$ = 2; }
   ;
   
opt_release: /* nil */	{ $$ = 0; }
   | NO RELEASE	{ $$ = 1; }
   | RELEASE	{ $$ = 2; }
   ;
   
rollback_stmt: ROLLBACK opt_work opt_chain opt_release { emit("STMT"); }
   ;
   
   /** set autocommit **/
stmt: set_autocommit_stmt { emit("STMT"); }
   ;
   
set_autocommit_stmt: SET AUTOCOMMIT COMPARISON expr
   ;
   
   /** savepoint,rollback savepoint, release savepoint **/
stmt: savepoint_stmt
   | rollback_to_savepoint_stmt
   | release_savepoint
   ;
   
   
savepoint_stmt: SAVEPOINT NAME	/* SAVEPOINT identifier */
   ;
   
rollback_to_savepoint_stmt: ROLLBACK opt_work TO SAVEPOINT NAME
   ;
   
release_savepoint: RELEASE SAVEPOINT NAME
   ;
   
   /** lock tables **/
stmt: lock_table_stmt  { emit("STMT"); }
   ;
   
lock_table_stmt: LOCK TABLES lock_table_list
   ;
   
lock_table_list: lock_table
   | lock_table_list ',' lock_table
   ;
   
lock_table: NAME opt_as_alias opt_read_write
   ;
   
opt_read_write: READ	{ $$ = 1; }
   | READ LOCAL			{ $$ = 2; }
   | LOW_PRIORITY WRITE { $$ = 3; }
   | WRITE				{ $$ = 4; }
   ;
   
   /** unlock tables **/
stmt: unlock_tables
   ;
   
unlock_tables: UNLOCK TABLES
   ;
   
   /** set transaction **/
stmt: set_transaction_stmt
   ;
   
set_transaction_stmt:
	SET opt_trans_level TRANSACTION ISOLATION LEVEL trans_att
   ;
	
opt_trans_level: /* nil */	{ $$ = 0; }
   | GLOBAL					{ $$ = 1; }
   | SESSION				{ $$ = 2; }
   ;
   
trans_att:
	READ UNCOMMITTED	{ $$ = 1; }
	| READ COMMITTED	{ $$ = 2; }
	| REPEATABLE READ	{ $$ = 3; }
	| SERIALIZABLE		{ $$ = 4; }
	;
   
   	/** create user **/
stmt: create_user_stmt { emit("STMT"); }
   ;
   
create_user_stmt: CREATE USER create_user_list
   ;

create_user_list: create_user
   | create_user_list ',' create_user
   ;
   
create_user: USERVAR
   | USERVAR IDENTIFIED BY STRING
   | USERVAR IDENTIFIED BY PASSWORD STRING
   ;
   
   /** drop user **/
stmt: drop_user_stmt { emit("STMT"); }
   ;

drop_user_stmt: DROP USER user_list
   ;
   
user_list: USERVAR
   | user_list ',' USERVAR
   ;
   
   /** grant all **/
stmt: grant_all_stmt { emit("STMT"); }
   ;
   
grant_all_stmt: GRANT priv_database_list ON '*' '.' '*' TO create_user_list opt_with_opt
	;
	
priv_database_list: priv_database_type
   | priv_database_list ',' priv_database_type
   ;
   
priv_database_type: 
	ALL		{ $$ = 01; }
   | ALL PRIVILEGES	{ $$ = 02; }
   | SELECT	{ $$ = 04; }
   | UPDATE { $$ = 010; }
   | INSERT	{ $$ = 020; }
   | DELETE	{ $$ = 040; }
   | CREATE	{ $$ = 0100; }
   | DROP	{ $$ = 0200; }
   | INDEX	{ $$ = 0400; }
   | ALTER	{ $$ = 01000; }
   | GRANT OPTION	{ $$ = 02000; }
   | REFERENCES		{ $$ = 04000; }
   ;
   
opt_with_opt: /* nil */
   | WITH with_opt
   ;
   
with_opt: 
	GRANT OPTION
   | MAX_QUERIES_PER_HOUR expr
   | MAX_UPDATES_PER_HOUR expr
   | MAX_CONNECTIONS_PER_HOUR expr
   | MAX_USER_CONNECTIONS expr
   ;
	
   /** grant database **/
stmt: grant_database_stmt { emit("STMT"); }
   ;
   
grant_database_stmt: GRANT priv_database_list ON NAME '.' '*' TO create_user_list opt_with_opt
   ;

   /** grant table **/
stmt: grant_table_stmt { emit("STMT"); }
   ;
   
grant_table_stmt: GRANT priv_table_list ON NAME '.' NAME TO create_user_list opt_with_opt
   ;
   
priv_table_list: priv_table_type
   | priv_table_list ',' priv_table_type
   ;
	
priv_table_type: 
	SELECT opt_col_names
   | UPDATE opt_col_names
   | INSERT opt_col_names
   | DELETE 
   | CREATE
   | DROP
   | INDEX
   | ALTER
   | GRANT OPTION
   ;
	/* 
	 for a table ,you can set the value of priv_type as
	SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, GRANT OPTION, INDEX ALTER。
	 for a column(in other words, you use one column_list subclause)
	the priv_type value can only be set as SELECT, INSERT UPDATE。
	*/

	/** revoke all **/
stmt: revoke_all_stmt { emit("STMT"); }
   ;
   
revoke_all_stmt: REVOKE priv_database_list ON '*' '.' '*' FROM user_list
	;
   /** revoke database **/
stmt: revoke_database_stmt  { emit("STMT"); }
   ;

revoke_database_stmt: REVOKE priv_database_list ON NAME '.' '*' FROM user_list opt_with_opt
   ;
   
stmt: revoke_table_stmt  { emit("STMT"); }
   ;

revoke_table_stmt: REVOKE priv_table_list ON NAME '.' NAME FROM user_list opt_with_opt
   ;
   
   /** rename user **/
stmt: rename_user_stmt { emit("STMT"); }
   ;
   
rename_user_stmt: RENAME USER utou_list
   ;
   
utou_list: 
	USERVAR TO USERVAR
   | utou_list ',' USERVAR TO USERVAR
   ;
   
   /** set password **/
stmt: set_password_stmt { emit("STMT"); }
   ;
   
set_password_stmt: SET PASSWORD opt_for_user COMPARISON PASSWORD '(' STRING ')'
   ;
   
opt_for_user: /* nil */
   | FOR USERVAR
   ;
   
   /** analyze table**/
stmt: analyze_table_stmt { emit("STMT"); }
   ;
   
analyze_table_stmt: ANALYZE analyze_opt TABLE table_list
   ;
   
analyze_opt: /* nil */	{ $$ = 0; }
   | LOCAL	{ $$ = 1; }
   | NO_WRITE_TO_BINLOG	{ $$ = 2; }
   ;
   
   /** backup table **/
stmt: backup_table_stmt { emit("STMT"); }
   ;
   
backup_table_stmt: BACKUP TABLE table_list TO STRING
   ;
   
   /** check table **/
stmt: check_table_stmt { emit("STMT"); }
   ;
   
check_table_stmt: CHECK TABLE table_list check_opts
   ;
   
check_opts: /* nil */	{ $$ = 0; }
   | QUICK	{ $$ = 1; }
   | FAST	{ $$ = 2; }
   | MEDIUM	{ $$ = 3; }
   | EXTENDED	{ $$ = 4; }
   | CHANGED	{ $$ = 5; }
   ;
   
   /** checksum table **/
stmt: checksum_table_stmt { emit("STMT"); }
   ;
   
checksum_table_stmt: CHECKSUM TABLE table_list checksum_opt
   ;
   
checksum_opt: /* nil */	{ $$ = 0; }
   | QUICK	{ $$ = 1; }
   | EXTENDED	{ $$ = 2; }
   ;
   
   /** optimize table **/
stmt: optimize_table_stmt { emit("STMT"); }
   ;
   
optimize_table_stmt: OPTIMIZE analyze_opt TABLE table_list
   ;
    
	/** repair table **/
stmt: repair_table_stmt { emit("STMT"); }
   ;
   
repair_table_stmt: REPAIR analyze_opt TABLE table_list repair_opts
   ;
   
repair_opts: /* nil */
   | repair_opts QUICK
   | repair_opts EXTENDED
   | repair_opts USE_FRM
   ;
   
	/** restore table **/
stmt: restore_table_stmt { emit("STMT"); }
   ;
   
restore_table_stmt: RESTORE TABLE table_list FROM STRING
   ;
   
stmt: show_stmt { $$ = $1; /*output($$, 1); puts("SQL parser： This is a show statement");*/ }
	;
   
show_stmt: SHOW opt_full TABLES opt_from opt_like_string	{ $$ = newShowStmt(1, $2, $4, $5,result->node_pointer); }
   | SHOW COLLATION opt_like_string
   | SHOW opt_full COLUMNS FROM NAME opt_from opt_like_string
   | SHOW CREATE DATABASE NAME
   | SHOW CREATE SCHEMA NAME
   | SHOW CREATE TABLE NAME
   | SHOW DATABASE NAME
   | SHOW SCHEMA NAME 
   | SHOW ENGINE NAME LOGS
   | SHOW ENGINE NAME STATUS
   | SHOW STORAGE ENGINES
   | SHOW ERRORS opt_limit
   | SHOW expr ERRORS  /* expr = COUNT(*) */
   | SHOW GRANTS FOR USERVAR
   | SHOW INDEX FROM NAME opt_from
   | SHOW INNODB STATUS
   | SHOW opt_bdb LOGS
   | SHOW OPEN TABLES opt_from opt_like_string
   | SHOW PRIVILEGES
   | SHOW opt_full PROCESSLIST
   | SHOW opt_trans_level STATUS opt_like_string
   | SHOW TABLE STATUS opt_from opt_like_string
   | SHOW CHARACTER SET opt_like_string
   | SHOW TRIGGERS opt_from opt_like_expr
   | SHOW opt_trans_level VARIABLES opt_like_string
   | SHOW WARNINGS opt_limit
   | SHOW expr WARNINGS /* expr = COUNT(*) */
   ;
   
opt_full: /* nil */	{ $$ = 0; }
   | FULL	{ $$ = 1; }
   ;
   
opt_from: /* nil */	{ $$ = NULL; }
   | FROM NAME	{ $$ = $2; }
   ;
   
opt_like_string: /* nil */	{ $$ = NULL; }
   | LIKE STRING	{ $$ = $2; }
   ;
   
opt_like_expr: /* nil */
   | LIKE expr
   ;
   
opt_bdb: /* nil */
   | BDB
   ;
   
   /* cache index */
stmt: cache_index_stmt
   ;
   
cache_index_stmt: CACHE INDEX  table_index_list IN NAME
   ;
   
table_index_list: table_index
   | table_index_list ',' table_index
   ;
   
table_index: NAME
   | NAME opt_index_key index_list
   ;
   
opt_index_key: /* nil */	{ $$ = 0; }
   | INDEX	{ $$ = 1; }
   | KEY	{ $$ = 2; }
   ;
   
   /* flush statement */
stmt: flush_stmt
   ;
   
flush_stmt: FLUSH analyze_opt flush_opt_list
   ;
   
flush_opt_list: flush_opt
   | flush_opt_list ',' flush_opt
   ;
   
flush_opt: HOSTS	{ $$ = 1; }
   | DES_KEY_FILE	{ $$ = 2; }
   | LOGS			{ $$ = 04; }
   | PRIVILEGES		{ $$ = 010; }
   | QUERY CACHE	{ $$ = 020; }
   | STATUS			{ $$ = 040; }
   | TABLE NAME		{ $$ = 0100; }
   | TABLES table_list		{ $$ = 0200; }
   | TABLES WITH READ LOCK	{ $$ = 0400; }
   | USER_RESOURCES			{ $$ = 01000; }
   ;
   
   /* kill statement */
stmt: kill_stmt
   ;
   
kill_stmt: KILL opt_connection_query expr
   ;
   
opt_connection_query: /* nil */	{ $$ = 0; }
   | CONNECTION	{ $$ = 1; }
   | QUERY		{ $$ = 2; }
   ;
   
   /** load index into cache **/
stmt: load_index_stmt
   ;
   
load_index_stmt: LOAD INDEX INTO CACHE table_index_list
   ;
   
table_index_list: NAME opt_index_key_list opt_ignore_leaves
   ;
   
opt_index_key_list: opt_index_key '(' index_list ')'
   ;
   
opt_ignore_leaves: /* nil */
   | IGNORE LEAVES
   ;
   
   /** reset statement **/
stmt: reset_stmt
   ;
   
reset_stmt: RESET reset_opt_list
   ;
   
reset_opt_list: reset_opt
   | reset_opt_list ',' reset_opt
   ;
   
reset_opt: MASTER	{ $$ = 1; }
   | QUERY CACHE	{ $$ = 2; }
   | SLAVE			{ $$ = 3; }
   ;
   
   /** prepare statement **/
stmt: prepare_stmt
   ;
   
prepare_stmt: PREPARE NAME FROM stmt
   | EXECUTE NAME opt_use_name
   | DEALLOCATE PREPARE NAME
   | DROP PREPARE NAME
   ;

opt_use_name: /* nil */
   | USING user_list
   ;

expr: '?'
   ;
   
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
    
   /**** set user variables ****/

stmt: set_stmt { emit("STMT"); }
   ;

set_stmt: SET set_list ;

set_list: set_expr | set_list ',' set_expr ;

set_expr:
	USERVAR COMPARISON expr 
	{ if ($2 != 4) yyerror(result,"bad set to @%s", $1);
		emit("SET %s", $1); free($1);
	}
    | USERVAR ASSIGN expr 
    {
    	emit("SET %s", $1); 
    	free($1); 
    }
    ;
    

opt_length: /* nil */		{ $$ = NULL; }
   | '(' INTNUM ')' 		{ $$ = newLength (t_length, atoi($2), 0,result->node_pointer); }
   | '(' INTNUM ',' INTNUM ')'	{ $$ = newLength (t_length, atoi($2), atoi($4),result->node_pointer); }
   ;

opt_binary: /* nil */	{ $$ = 0; }
   | BINARY		{ $$ = 1; }
   ;

opt_uz: /* nil */ 	{ $$ = 0; }
   | opt_uz UNSIGNED	{ $$ = $1 | 01; }	
   | opt_uz ZEROFILL	{ $$ = $1 | 02; }
   ;

opt_csc: /* nil */		{ $$ =newOptCsc(t_opt_csc, 0, NULL, NULL,result->node_pointer);}
   | opt_csc CHAR SET NAME	
		{ Opt_csc * t = (Opt_csc *)$1; t->datatype = t->datatype | 01; t->s1 = $4; $$ = (Node *)t; }
   | opt_csc COLLATE NAME
		{ Opt_csc * t = (Opt_csc *)$1; t->datatype = t->datatype | 02; t->s2 = $3; $$ = (Node *)t; }
   ;

data_type:		// 2-18--change expression of every class according the position and size---byYU
   BIT opt_length				{ $$ = newDatatype (t_datatype, 1, $2, 0, NULL, 0, NULL,result->node_pointer); }
   | TINYINT opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 2, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | SMALLINT opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 3, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | MEDIUMINT opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 4, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | INT opt_length opt_uz		{ $$ = newDatatype (t_datatype, 5, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | INTEGER opt_length opt_uz	{ $$ = newDatatype (t_datatype, 6, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | BIGINT opt_length opt_uz		{ $$ = newDatatype (t_datatype, 7, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | REAL opt_length opt_uz		{ $$ = newDatatype (t_datatype, 8, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | DOUBLE opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 9, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | FLOAT opt_length opt_uz 		{ $$ = newDatatype (t_datatype, 10, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | DECIMAL opt_length opt_uz 	{ $$ = newDatatype (t_datatype, 11, $2, $3, NULL, 0, NULL,result->node_pointer); }
   | DATE 					{ $$ = newDatatype (t_datatype, 12, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | TIME					{ $$ = newDatatype (t_datatype, 13, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | TIMESTAMP				{ $$ = newDatatype (t_datatype, 14, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | DATETIME 				{ $$ = newDatatype (t_datatype, 15, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | YEAR 					{ $$ = newDatatype (t_datatype, 16, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | CHAR opt_length opt_csc	 	{ $$ = newDatatype (t_datatype, 17, $2, 0, $3, 0, NULL,result->node_pointer); }
   | VARCHAR '(' INTNUM ')' opt_csc	{ Node * t = newLength(t_datatype, atoi($3), NULL,result->node_pointer); $$ = newDatatype (t_datatype, 18, t, 0, $5, 0, NULL,result->node_pointer); }
   | BINARY opt_length 			{ $$ = newDatatype (t_datatype, 19, $2, 0, NULL, 0, NULL,result->node_pointer); }
   | VARBINARY '(' INTNUM ')' 	{  Node * t = newLength(t_datatype, atoi($3), NULL,result->node_pointer); $$ = newDatatype (t_datatype, 20, t, 0, NULL, 0, NULL,result->node_pointer); }
   | TINYBLOB 				{ $$ = newDatatype (t_datatype, 21, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | BLOB 					{ $$ = newDatatype (t_datatype, 22, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | MEDIUMBLOB				{ $$ = newDatatype (t_datatype, 23, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | LONGBLOB				{ $$ = newDatatype (t_datatype, 24, NULL, 0, NULL, 0, NULL,result->node_pointer); }
   | TINYTEXT opt_binary opt_csc	{ $$ = newDatatype (t_datatype, 25, NULL, 0, $3, $2, NULL,result->node_pointer); }
   | TEXT opt_binary opt_csc 		{ $$ = newDatatype (t_datatype, 26, NULL, 0, $3, $2, NULL,result->node_pointer); }
   | MEDIUMTEXT opt_binary opt_csc	{ $$ = newDatatype (t_datatype, 27, NULL, 0, $3, $2, NULL,result->node_pointer); }
   | LONGTEXT opt_binary opt_csc  	{ $$ = newDatatype (t_datatype, 28, NULL, 0, $3, $2, NULL,result->node_pointer); }
   | ENUM '(' enum_list ')' opt_csc	{ $$ = newDatatype (t_datatype, 29, NULL, 0, $5, 0, $3,result->node_pointer); }
   | SET '(' enum_list ')' opt_csc	{ $$ = newDatatype (t_datatype, 30, NULL, 0, $5, 0, $3,result->node_pointer); }
   ;

enum_list: STRING 		{ $$ = newEnumList( t_enum_list, $1, NULL,result->node_pointer); }
   | enum_list ',' STRING	{ $$ = newEnumList( t_enum_list, $3, $1,result->node_pointer); }
   ;


   /**** expressions ****/	// 2014-4-14---modify because of the change of value type---by Yu
expr: NAME         { $$ = newColumn(t_name, NULL, $1, NULL,result->node_pointer); /*puts("expr1");*/ }//---3.5fzh---
   | USERVAR       { $$ = newExpr(t_name, $1,result->node_pointer); }
   | NAME '.' NAME { $$ = newColumn(t_name_name, $1, $3, NULL,result->node_pointer); /*puts("expr2");*/ }
   | NAME '.' '*'  { $$ = newColumn(t_name_name, $1, "*", NULL,result->node_pointer);/* puts("expr22");*/}//---3.6fzh---
   | STRING        { $$ = newExpr(t_stringval, $1,result->node_pointer); /*puts("expr3");*/ }
   | INTNUM        { $$ = newExpr(t_intnum, $1,result->node_pointer); /*puts("expr4");*/ }	
   | APPROXNUM     { $$ = newExpr(t_approxnum, $1,result->node_pointer); }	
   | BOOL          { $$ = newExpr(t_bool, $1,result->node_pointer); }
   ;

expr: expr '+' expr 		{ $$=newExprCal(t_expr_cal, "+", NULL, 0, $1, $3,result->node_pointer); }
   | expr '-' expr 		{ $$=newExprCal(t_expr_cal, "-", NULL, 0, $1, $3,result->node_pointer); }
   | expr '*' expr  		{ $$=newExprCal(t_expr_cal, "*", NULL, 0, $1, $3,result->node_pointer); }
   | expr '/' expr 		{ $$=newExprCal(t_expr_cal, "/", NULL, 0, $1, $3,result->node_pointer); }
   | expr '%' expr 		{ $$=newExprCal(t_expr_cal, "%", NULL, 0, $1, $3,result->node_pointer); }
   | expr MOD expr 		{ $$=newExprCal(t_expr_cal, "MOD", NULL, 0, $1, $3,result->node_pointer); }
   | '-' expr %prec UMINUS	{ $$=newExprCal(t_expr_cal, "--", NULL, 0, NULL, $2,result->node_pointer); }	
   | '+' expr %prec UMINUS	{ $$=newExprCal(t_expr_cal, "++", NULL, 0, NULL, $2,result->node_pointer); }	
   | expr ANDOP expr		{ $$=newExprCal(t_expr_cal, "ANDOP", NULL, 0, $1, $3,result->node_pointer); }
   | expr OR expr			{ $$=newExprCal(t_expr_cal, "OR", NULL, 0, $1, $3,result->node_pointer); }
   | expr XOR expr		{ $$=newExprCal(t_expr_cal, "XOR", NULL, 0, $1, $3,result->node_pointer); }
   | expr COMPARISON expr	{ $$ = newExprCal(t_expr_cal, "CMP", NULL, $2, $1, $3,result->node_pointer);/* puts("=");*/ }
   | expr COMPARISON '(' select_stmt ')'		{ $$=newExprCal(t_expr_cal, "CMP", NULL, $2, $1, $4,result->node_pointer); }
   | expr COMPARISON ANY '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "CMP", "ANY", $2, $1, $5,result->node_pointer); }
   | expr COMPARISON SOME '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "CMP", "SOME", $2, $1, $5,result->node_pointer); }
   | expr COMPARISON ALL '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "CMP", "ALL", $2, $1, $5,result->node_pointer); }
   | expr '|' expr	{ $$=newExprCal(t_expr_cal, "|", NULL, 0, $1, $3,result->node_pointer); }
   | expr '&' expr	{ $$=newExprCal(t_expr_cal, "&", NULL, 0, $1, $3,result->node_pointer); }
   | expr '^' expr	{ $$=newExprCal(t_expr_cal, "^", NULL, 0, $1, $3,result->node_pointer); }
   | expr SHIFT expr	{ $$=newExprCal(t_expr_cal, (SHIFT==1?"LS":"RS"), NULL, 0, $1, $3,result->node_pointer); }
   | NOT expr %dprec 1	{ $$=newExprCal(t_expr_cal, "NOT", NULL, 0, NULL, $2,result->node_pointer); }
   | '!' expr		{ $$=newExprCal(t_expr_cal, "!", NULL, 0, NULL, $2,result->node_pointer); }
   | USERVAR ASSIGN expr	{ $$=NULL; }		//---------------------------------------------
   | '(' expr ')'		{ $$ = $2; }
   ;    

expr:  expr IS NULLX     { $$=newExprFunc(t_expr_func, "ISN", $1, NULL, NULL, NULL,result->node_pointer); }
   |   expr IS NOT NULLX { $$=newExprFunc(t_expr_func, "ISNN", $1, NULL, NULL, NULL,result->node_pointer); }
   |   expr IS BOOL      { $$=newExprFunc(t_expr_func, "ISB", $1, NULL, NULL, NULL,result->node_pointer); }
   |   expr IS NOT BOOL  { $$=newExprFunc(t_expr_func, "ISNB", $1, NULL, NULL, NULL,result->node_pointer); }
   ;

expr: expr BETWEEN expr AND expr %prec BETWEEN { $$=newExprFunc(t_expr_func, "BA", $1, $3, $5, NULL,result->node_pointer); }
   ;



expr_list: expr		{ $$ = newExprList(t_expr_list, $1, NULL,result->node_pointer); }

   | expr ',' expr_list { $$ = newExprList(t_expr_list, $1, $3,result->node_pointer); }

   | '(' expr_list ')'	{ $$ =$2; }	

   ;

opt_expr_list:  expr_list {$$ = newExprList(t_expr_list, $1, NULL,result->node_pointer);}  //---8.17---fzh---change the list,so some where should changed as it;
   | expr_list ',' opt_expr_list {$$ = newExprList(t_expr_list, $1, $3,result->node_pointer);}
   ;
//set_operator

expr: expr IN '(' expr_list ')'			{ $$=newExprCal(t_expr_cal, "INVS", NULL, 0, $1, $4,result->node_pointer); }
   | '(' expr_list ')' IN '(' opt_expr_list ')'	{$$=newExprCal(t_expr_cal, "INVM", NULL, 0, $2, $6,result->node_pointer);}
   | expr NOT IN '(' expr_list ')'			{ $$=newExprCal(t_expr_cal, "NINS", NULL, 0, $1, $5,result->node_pointer); }
   | '(' expr_list ')' NOT IN  '(' expr_list ')'	{ $$=newExprCal(t_expr_cal, "NINM", NULL, 0, $2, $7,result->node_pointer); }
   | expr IN '(' select_stmt ')'			{ $$=newExprCal(t_expr_cal, "INS", NULL, 0, $1, $4,result->node_pointer); }
   | '(' expr_list ')' IN '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "INS", NULL, 0, $2, $6,result->node_pointer); }
   | expr NOT IN '(' select_stmt ')'		{ $$=newExprCal(t_expr_cal, "NINS", NULL, 0, $1, $5,result->node_pointer); }
   | '(' expr_list ')' NOT IN '(' select_stmt ')'	{ $$=newExprCal(t_expr_cal, "NINS", NULL, 0, $2, $7,result->node_pointer); }
   | EXISTS '(' select_stmt ')'			{ $$=newExprCal(t_expr_cal, "EX", NULL, 0, NULL, $3,result->node_pointer); }
   | NOT EXISTS '(' select_stmt ')'	%dprec 2	{ $$=newExprCal(t_expr_cal, "NINS", NULL, 0, NULL, $4,result->node_pointer); } 
   ;

expr: NAME '(' opt_expr_list ')'	{ $$=newExprCal(t_expr_cal, "NAME", $1, 0, NULL, $3,result->node_pointer); }   
   ;

  /* functions with special syntax */
expr: FCOUNT '(' '*' ')'	{ $$=newExprFunc(t_expr_func, "FCOUNTALL", NULL, NULL, NULL, NULL,result->node_pointer); }
   | FCOUNT '(' expr ')'	{ $$=newExprFunc(t_expr_func, "FCOUNT", NULL, $3, NULL, NULL,result->node_pointer); }
   //---2.18 add aggrection function
	|FSUM '(' expr ')' { $$=newExprFunc(t_expr_func, "FSUM", NULL, $3, NULL, NULL,result->node_pointer); }
	|FAVG '(' expr ')' { $$=newExprFunc(t_expr_func, "FAVG", NULL, $3, NULL, NULL,result->node_pointer); }
	|FMIN '(' expr ')' { $$=newExprFunc(t_expr_func, "FMIN", NULL, $3, NULL, NULL,result->node_pointer); }
	|FMAX '(' expr ')' { $$=newExprFunc(t_expr_func, "FMAX", NULL, $3, NULL, NULL,result->node_pointer); }
   
   ;

   //---3.25fzh---sds
expr: FSUBSTRING'(' expr ',' expr ')'		{ $$=newExprFunc(t_expr_func, "FSUBSTRING0", $3, $5, NULL, NULL,result->node_pointer); }
   | FSUBSTRING'(' expr FROM expr ')'		{ $$=newExprFunc(t_expr_func, "FSUBSTRING0", $3, $5, NULL, NULL,result->node_pointer);}
   | FSUBSTRING'(' expr ',' expr ',' expr ')' { $$=newExprFunc(t_expr_func, "FSUBSTRING1", $3, $5, $7, NULL,result->node_pointer); }
   | FSUBSTRING'(' expr FROM expr FOR expr ')' { $$=newExprFunc(t_expr_func, "FSUBSTRING1", $3, $5, $7, NULL,result->node_pointer); }
   | FTRIM'(' expr ')'						{ $$=newExprFunc(t_expr_func, "FTRIM3", NULL, $3, NULL, NULL,result->node_pointer); }
   | FTRIM'(' trim_ltb expr FROM expr ')'	{ $$=newExprFunc(t_expr_func,$3, NULL, $4, $6, NULL,result->node_pointer); }
   | FUPPER'(' expr ')'   					{ $$=newExprFunc(t_expr_func,"FUPPER", NULL, $3, NULL, NULL,result->node_pointer); }
   | FCAST '(' expr AS date_type ')'        {$$=newExprFunc(t_expr_func,"FCAST", NULL, $3, $5, NULL,result->node_pointer); }
   | FCOALESCE'(' expr_list ')'             { $$=newExprFunc(t_expr_func,"FCOALESCE", NULL, $3,NULL, NULL,result->node_pointer); }
   ;
trim_ltb: LEADING   { $$="FTRIM1"; }
   | TRAILING 		{ $$="FTRIM2"; }
   | BOTH 			{ $$="FTRIM0"; }
   ;
date_type:     {$$=NULL;} 
   | INTEGER   { char d[10]="int"; $$ = newExpr(t_stringval, d,result->node_pointer);}
   | STRING    { char d[10] = "string"; $$ = newExpr(t_stringval, d,result->node_pointer);}
   | DOUBLE    { char d[10] = "double"; $$ = newExpr(t_stringval, d,result->node_pointer);}
   | FLOAT     { char d[10] = "float"; $$ = newExpr(t_stringval, d,result->node_pointer);}
   | CHAR      { char d[10] = "char"; $$ = newExpr(t_stringval, d,result->node_pointer);}
   ;
//////////////////
//---5.26fzh---

expr: FDATE_ADD '(' expr ',' interval_exp ')' { $$=newExprFunc(t_expr_func, "FDATE_ADD", $3, $5, NULL, NULL,result->node_pointer); }
   |  FDATE_SUB '(' expr ',' interval_exp ')' { $$=newExprFunc(t_expr_func, "FDATE_SUB", $3, $5, NULL, NULL,result->node_pointer); }
   ;
interval_exp: 
	INTERVAL expr DAY_HOUR         	   { $$=newExprFunc(t_expr_func, "INTERVAL_HOUR",        $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr DAY_MICROSECOND     { $$=newExprFunc(t_expr_func, "INTERVAL_MICROSECOND", $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr DAY_MINUTE          { $$=newExprFunc(t_expr_func, "INTERVAL_MINUTE",      $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr DAY_SECOND          { $$=newExprFunc(t_expr_func, "INTERVAL_SECOND",      $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr DAY                 { $$=newExprFunc(t_expr_func, "INTERVAL_DAY",         $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr YEAR_MONTH          { $$=newExprFunc(t_expr_func, "INTERVAL_MONTH",       $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr YEAR                { $$=newExprFunc(t_expr_func, "INTERVAL_YEAR",        $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr WEEK                { $$=newExprFunc(t_expr_func, "INTERVAL_WEEK",        $2, NULL, NULL, NULL,result->node_pointer);  }
   | INTERVAL expr QUARTER             { $$=newExprFunc(t_expr_func, "INTERVAL_QUARTER",     $2, NULL, NULL, NULL,result->node_pointer);  }
   ;
//---5.26fzh---
	
expr: CASE expr case_list END			{ $$=newExprFunc(t_expr_func, "CASE1", $2, $3, NULL, NULL,result->node_pointer); }//---3.8fzh---
   |  CASE expr case_list ELSE expr END	{ $$=newExprFunc(t_expr_func, "CASE2", $2, $3, $5, NULL,result->node_pointer); }
   |  CASE case_list END                { $$=newExprFunc(t_expr_func, "CASE3", NULL, $2, NULL, NULL,result->node_pointer); }
   |  CASE case_list ELSE expr END      { $$=newExprFunc(t_expr_func, "CASE4", NULL, $2, $4, NULL,result->node_pointer); }
   ;

case_list: WHEN expr THEN expr	{ $$=newExprFunc(t_expr_func, "WHEN2", NULL, $2, $4, NULL,result->node_pointer); }
   | case_list WHEN expr THEN expr	{ $$=newExprFunc(t_expr_func, "WHEN2", NULL, $3, $5, $1,result->node_pointer); }
   ;

expr: expr LIKE expr	{ $$=newExprCal(t_expr_cal, "LIKE", NULL, 0, $1, $3,result->node_pointer); }
   | expr NOT LIKE expr { $$=newExprCal(t_expr_cal, "NLIKE", NULL, 0, $1, $4,result->node_pointer); }
   ;

expr: expr REGEXP expr		{ $$=newExprCal(t_expr_cal, "REGEXP", NULL, 0, $1, $3,result->node_pointer); }
   | expr NOT REGEXP expr	{ $$=newExprCal(t_expr_cal, "NREGEXP", NULL, 0, $1, $4,result->node_pointer); }
   ;

expr: CURRENT_TIMESTAMP //85{ emit("NOW") };
   | CURRENT_DATE	//86{ emit("NOW") };
   | CURRENT_TIME	//87{ emit("NOW") };
   ;

expr: BINARY expr %prec UMINUS //88{ emit("STRTOBIN"); }
   ;

%%

void emit(char *s, ...)
{
 /* extern int yylineno;

  va_list ap;
  va_start(ap, s);

  printf("rpn: ");
  vfprintf(stdout, s, ap);
  printf("\n");*/
}

void yyerror(struct ParseResult *pp,const char *  s, ...)
{
/*  va_list ap;
  va_start(ap, s);

  fprintf(stderr, "%d: error: ", yyget_lineno(pp->yyscan_info_));
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");*/
fprintf (stderr, "%s\n", s);
}

/*
int readInputForLexer( char *buffer, int *numBytesRead, int maxBytesToRead ) {
	int numBytesToRead = maxBytesToRead;
	int bytesRemaining = strlen(globalInputText)-globalReadOffset;
	int i;
	if ( numBytesToRead > bytesRemaining ) { numBytesToRead = bytesRemaining; }
	for ( i = 0; i < numBytesToRead; i++ ) {
		buffer[i] = globalInputText[globalReadOffset+i];
	}
	*numBytesRead = numBytesToRead;
	globalReadOffset += numBytesToRead;
	return 0;
}


main(int ac, char **av)
{
	char c;
	while(1)
	{
		int charnum=0;
		memset(globalInputText, 0, sizeof(globalInputText));
		//cout<<"globalInputText: "<<globalInputText;
		globalReadOffset = 0;
	    	while(1)
		{
			c=getchar();
			globalInputText[charnum++]=c;
			if(c==';')
			{
				globalInputText[charnum++]='\0';
				break;
			}
		}
//		strcpy(globalInputText, "select a from b; sd; select a from b;");	// 2014-3-4---测试用---byYU
		cout<<"globalInputText: "<<globalInputText<<endl;
		if(!yyparse())
	    		printf("SQL parse worked\n");
		else
    			printf("SQL parse failed\n");
		puts("input a number! 0 quit, 1 continue");
		c = getchar();
		while( c == '\n')
			c= getchar();
		if (c == '0') 
			break;
		else 
			cout<<c<<endl;
		getchar();
	}
} 
*/
