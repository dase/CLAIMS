/*
 * Aggregation.h
 *
 *  Created on: Nov 11, 2013
 *      Author: wangli
 */

#ifndef AGGREGATION_H_
#define AGGREGATION_H_
#include <vector>
#include "LogicalOperator.h"
#include "../Catalog/Attribute.h"
#include "../BlockStreamIterator/ParallelBlockStreamIterator/BlockStreamAggregationIterator.h"
class Aggregation: public LogicalOperator {
public:
	enum fashion{no_repartition,repartition,hybrid};

	/**
	 * This the default construct method of Aggregation.
	 * This logical operator creates a new dataflow.
	 * group_by_attribute can be empty if it is scalar aggregation.
	 * count(*) aggregation can be expressed as 'count' aggregation function along with Attribute(ATTRIBUTE_ANY)
	 */
	Aggregation(std::vector<Attribute> group_by_attribute,std::vector<Attribute> aggregation_attribute,std::vector<BlockStreamAggregationIterator::State::aggregation> aggregation_list,LogicalOperator* child);
	virtual ~Aggregation();
	Dataflow getDataflow();
	BlockStreamIteratorBase* getIteratorTree(const unsigned & block_size);

	std::vector<unsigned> getInvolvedIndexList(const std::vector<Attribute>& attribute_list,const Dataflow& dataflow )const;
private:
	bool canLeverageHashPartition(const Dataflow& child_dataflow)const;
	float predictSelectivity()const;

	/* in the hybrid aggregation schema, local aggregation may be different from global aggregation.
	 * For instance, to achieve count(*) aggregation, the local is count(*) while the global
	 * one should be sum(*) to guarantee the correctness.
	 */
	std::vector<BlockStreamAggregationIterator::State::aggregation> convertionForHybrid(const std::vector<BlockStreamAggregationIterator::State::aggregation>)const;
	void print(int level=0)const;

	/**
	 * generate a list containing attributes that are generated by the aggregation algorithm.
	 */
	std::vector<Attribute> getAttributesListAfterAggregation()const;
	std::vector<Attribute> getGroupByAttributeAfterAggregation()const;
	std::vector<Attribute> getAggregationAttributeAfterAggregation()const;

	unsigned long estimateGroupByCardinality(const Dataflow& dataflow)const;


private:
	LogicalOperator* child_;
	std::vector<Attribute> group_by_attribute_list_;
	std::vector<Attribute> aggregation_attribute_list_;
	std::vector<BlockStreamAggregationIterator::State::aggregation> aggregation_list_;
	Dataflow* dataflow_;
	fashion fashion_;
};

#endif /* AGGREGATION_H_ */
